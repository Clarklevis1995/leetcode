解法一：
直接使用Arrays.sort(nums),Arrays自带的排序方法是快速排序，时间复杂度为nlogn，然后从数组中找到倒数第k个数  
解法二：
利用快速选择算法：  
快速选择算法是快速排序算法的改进，可以根据需求只从某一个子数组中进行查找，可以提前结束快速排序
* 首先会用到快速排序中的工具方法：partition， swap
* 为了防止最差情况的产生，加入了随机影响，随机调换数组最后一位和数组中的某一位
* 因为每次partition都会确定一个元素的实际位置p，只要将这个位置和所要求的位置 index = nums.length - k 比较即可
* 如果p<index: 从右边的子数组开始找， 如果p>index, 从左边的子数组开始找，结束条件：p==index，此时p就是要找的第k大的数

解法三：利用堆排序
